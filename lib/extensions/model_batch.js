// Generated by CoffeeScript 1.6.3
(function() {
  var BATCH_DEFAULT_LIMIT, BATCH_DEFAULT_PARALLELISM, Cursor, Queue, _;

  _ = require('underscore');

  Queue = require('../queue');

  Cursor = null;

  BATCH_DEFAULT_LIMIT = 1000;

  BATCH_DEFAULT_PARALLELISM = 1;

  module.exports = function(model_type, query, options, callback, fn) {
    var batch_cursor, method, parallelism, parsed_query, processed_count, runBatch, _ref, _ref1;
    if (!Cursor) {
      Cursor = require('../cursor');
    }
    if (arguments.length === 3) {
      _ref = [{}, {}, query, options], query = _ref[0], options = _ref[1], callback = _ref[2], fn = _ref[3];
    }
    if (arguments.length === 4) {
      _ref1 = [{}, query, options, callback], query = _ref1[0], options = _ref1[1], callback = _ref1[2], fn = _ref1[3];
    }
    processed_count = 0;
    parsed_query = Cursor.parseQuery(query);
    parallelism = options.hasOwnProperty('parallelism') ? options.parallelism : BATCH_DEFAULT_PARALLELISM;
    method = options.method || 'toModels';
    runBatch = function(batch_cursor, callback) {
      var cursor;
      cursor = model_type.cursor(batch_cursor);
      return cursor[method].call(cursor, function(err, models) {
        var model, queue, _fn, _i, _len;
        if (err || !models) {
          return callback(new Error("Failed to get models. Error: " + err));
        }
        if (!models.length) {
          return callback(null, processed_count);
        }
        queue = new Queue(parallelism);
        _fn = function(model) {
          return queue.defer(function(callback) {
            return fn(model, callback);
          });
        };
        for (_i = 0, _len = models.length; _i < _len; _i++) {
          model = models[_i];
          _fn(model);
          processed_count++;
          if (parsed_query.cursor.$limit && (processed_count >= parsed_query.cursor.$limit)) {
            break;
          }
        }
        return queue.await(function(err) {
          if (err) {
            return callback(err);
          }
          if (parsed_query.cursor.$limit && (processed_count >= parsed_query.cursor.$limit)) {
            return callback(null, processed_count);
          }
          if (models.length < batch_cursor.$limit) {
            return callback(null, processed_count);
          }
          batch_cursor.$offset += batch_cursor.$limit;
          return runBatch(batch_cursor, callback);
        });
      });
    };
    batch_cursor = _.extend({
      $limit: options.$limit || BATCH_DEFAULT_LIMIT,
      $offset: parsed_query.cursor.$offset || 0,
      $sort: parsed_query.cursor.$sort || 'id'
    }, parsed_query.find);
    return runBatch(batch_cursor, callback);
  };

}).call(this);
