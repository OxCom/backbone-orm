// Generated by CoffeeScript 1.6.3
/*
  backbone-orm.js 0.0.1
  Copyright (c) 2013 Vidigami - https://github.com/vidigami/backbone-orm
  License: MIT (http://www.opensource.org/licenses/mit-license.php)
  Dependencies: Backbone.js and Underscore.js.
*/


(function() {
  var Backbone, One, Queue, Utils, inflection, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ = require('underscore');

  Backbone = require('backbone');

  inflection = require('inflection');

  Queue = require('../queue');

  Utils = require('../utils');

  module.exports = One = (function(_super) {
    __extends(One, _super);

    function One(model_type, key, options) {
      var value;
      this.model_type = model_type;
      this.key = key;
      for (key in options) {
        value = options[key];
        this[key] = value;
      }
      this.virtual_id_accessor || (this.virtual_id_accessor = "" + this.key + "_id");
      if (!this.join_key) {
        this.join_key = inflection.foreign_key(this.model_type.model_name);
      }
      if (!this.foreign_key) {
        this.foreign_key = inflection.foreign_key(this.type === 'belongsTo' ? this.key : this.as || this.model_type.model_name);
      }
    }

    One.prototype.initialize = function() {
      this.reverse_relation = this._findOrGenerateReverseRelation(this);
      if (this.embed && this.reverse_relation && this.reverse_relation.embed) {
        throw new Error("Both relationship directions cannot embed (" + this.model_type.model_name + " and " + this.reverse_model_type.model_name + "). Choose one or the other.");
      }
    };

    One.prototype.initializeModel = function(model) {
      if (!model.isLoadedExists(this.key)) {
        model.setLoaded(this.key, this.isEmbedded());
      }
      return this._bindBacklinks(model);
    };

    One.prototype.releaseModel = function(model) {
      this._unbindBacklinks(model);
      return delete model._orm;
    };

    One.prototype.set = function(model, key, value, options) {
      var is_model, merge_into_existing, new_related_id, previous_related_id, previous_related_model;
      if (!((key === this.key) || (key === this.virtual_id_accessor) || (key === this.foreign_key))) {
        throw new Error("One.set: Unexpected key " + key + ". Expecting: " + this.key + " or " + this.virtual_id_accessor + " or " + this.foreign_key);
      }
      if (_.isArray(value)) {
        throw new Error("One.set: cannot set an array for attribute " + this.key + " on " + this.model_type.model_name);
      }
      if (_.isUndefined(value)) {
        value = null;
      }
      if (value === (previous_related_model = model.get(this.key))) {
        return this;
      }
      is_model = Utils.isModel(value);
      new_related_id = Utils.dataId(value);
      previous_related_id = Utils.dataId(previous_related_model);
      Utils.orSet(model, 'rel_dirty', {})[this.key] = true;
      if ((previous_related_id !== new_related_id) || !model.isLoaded(this.key)) {
        if ((is_model && (value.isLoaded())) && (new_related_id !== value)) {
          model.setLoaded(this.key, true);
        } else {
          model.setLoaded(this.key, _.isNull(value));
        }
      }
      if (value && !is_model) {
        if (!(merge_into_existing = previous_related_id === new_related_id)) {
          value = Utils.updateOrNew(value, this.reverse_model_type);
        }
      }
      if (!merge_into_existing) {
        Backbone.Model.prototype.set.call(model, this.key, value, options);
      }
      if (merge_into_existing) {
        Utils.updateModel(previous_related_model, value);
      } else if ((value === null) && this.reverse_relation && (this.reverse_relation.type === 'hasOne' || this.reverse_relation.type === 'belongsTo')) {
        if (!(this.embed || this.reverse_relation.embed)) {
          if (model.isLoaded(this.key) && previous_related_model && (previous_related_model.get(this.reverse_relation.key) === model)) {
            previous_related_model.set(this.reverse_relation.key, null);
          }
        }
      }
      return this;
    };

    One.prototype.get = function(model, key, callback) {
      var is_loaded, result, returnValue,
        _this = this;
      if (!((key === this.key) || (key === this.virtual_id_accessor) || (key === this.foreign_key))) {
        throw new Error("One.get: Unexpected key " + key + ". Expecting: " + this.key + " or " + this.virtual_id_accessor + " or " + this.foreign_key);
      }
      returnValue = function() {
        var related_model;
        if (!(related_model = model.attributes[_this.key])) {
          return null;
        }
        if (key === _this.virtual_id_accessor) {
          return related_model.id;
        } else {
          return related_model;
        }
      };
      if (callback && !this.isVirtual() && !this.manual_fetch && !(is_loaded = model.isLoaded(this.key))) {
        this.cursor(model, key).toJSON(function(err, json) {
          var previous_related_model, related_model;
          if (err) {
            return callback(err);
          }
          if (key !== _this.virtual_id_accessor) {
            model.setLoaded(_this.key, true);
          }
          previous_related_model = model.get(_this.key);
          if (previous_related_model && (previous_related_model.id === (json != null ? json.id : void 0))) {
            Utils.updateModel(previous_related_model, json);
          } else {
            related_model = json ? Utils.updateOrNew(json, _this.reverse_model_type) : null;
            model.set(_this.key, related_model);
          }
          return callback(null, returnValue());
        });
      }
      result = returnValue();
      if (callback && (is_loaded || this.manual_fetch)) {
        callback(null, result);
      }
      return result;
    };

    One.prototype.save = function(model, callback) {
      var related_model;
      if (!this._hasChanged(model)) {
        return callback();
      }
      delete Utils.orSet(model, 'rel_dirty', {})[this.key];
      if (!(related_model = model.attributes[this.key])) {
        return callback();
      }
      return this._saveRelated(model, [related_model], callback);
    };

    One.prototype.patchAdd = function(model, related, callback) {
      var found_related, related_id,
        _this = this;
      if (!model.id) {
        return callback(new Error("One.patchAdd: model has null id for: " + this.key));
      }
      if (!related) {
        return callback(new Error("One.patchAdd: missing model for: " + this.key));
      }
      if (_.isArray(related)) {
        return callback(new Error("One.patchAdd: should be provided with one model only for key: " + this.key));
      }
      if (!(related_id = Utils.dataId(related))) {
        return callback(new Error("One.patchAdd: cannot add a new model. Please save first."));
      }
      if (this.reverse_model_type.cache && !Utils.isModel(related)) {
        if (found_related = this.reverse_model_type.cache.get(related_id)) {
          Utils.updateModel(found_related, related);
          related = found_related;
        }
      }
      model.set(this.key, related);
      if (this.type === 'belongsTo') {
        return this.model_type.cursor({
          id: model.id,
          $one: true
        }).toJSON(function(err, model_json) {
          if (err) {
            return callback(err);
          }
          if (!model_json) {
            return callback(new Error("Failed to fetch model with id: " + model.id));
          }
          model_json[_this.foreign_key] = related_id;
          return model.save(model_json, callback);
        });
      } else {
        return this.cursor(model, this.key).toJSON(function(err, current_related_json) {
          var queue;
          if (err) {
            return callback(err);
          }
          if (current_related_json && (related_id === current_related_json.id)) {
            return callback();
          }
          queue = new Queue(1);
          if (current_related_json) {
            queue.defer(function(callback) {
              return _this.patchRemove(model, current_related_json, callback);
            });
          }
          queue.defer(function(callback) {
            var query, related_json;
            if (Utils.isModel(related)) {
              if (related.isLoaded()) {
                related_json = related.toJSON();
              }
            } else if (related_id !== related) {
              related_json = related;
            }
            if (related_json) {
              related_json[_this.reverse_relation.foreign_key] = model.id;
              return Utils.modelJSONSave(related_json, _this.reverse_model_type, callback);
            } else {
              query = {
                $one: true
              };
              query.id = related_id;
              return _this.reverse_model_type.cursor(query).toJSON(function(err, related_json) {
                if (err) {
                  return callback(err);
                }
                if (!related_json) {
                  return callback();
                }
                related_json[_this.reverse_relation.foreign_key] = model.id;
                return Utils.modelJSONSave(related_json, _this.reverse_model_type, callback);
              });
            }
          });
          return queue.await(callback);
        });
      }
    };

    One.prototype.patchRemove = function(model, relateds, callback) {
      var current_related_model, related, related_ids, _i, _len,
        _this = this;
      if (arguments.length === 2) {
        callback = relateds;
        relateds = void 0;
      }
      if (!model.id) {
        return callback(new Error("One.patchRemove: model has null id for: " + this.key));
      }
      if (arguments.length === 2) {
        if (!this.reverse_relation) {
          return callback();
        }
        if (Utils.isModel(model)) {
          delete Utils.orSet(model, 'rel_dirty', {})[this.key];
        }
        this.cursor(model, this.key).toJSON(function(err, related_json) {
          if (err) {
            return callback(err);
          }
          if (!related_json) {
            return callback();
          }
          related_json[_this.reverse_relation.foreign_key] = null;
          return Utils.modelJSONSave(related_json, _this.reverse_model_type, callback);
        });
        return;
      }
      if (this.isEmbedded()) {
        return callback(new Error('One.patchRemove: embedded relationships are not supported'));
      }
      if (!relateds) {
        return callback(new Error('One.patchRemove: missing model for remove'));
      }
      if (!_.isArray(relateds)) {
        relateds = [relateds];
      }
      if (current_related_model = model.get(this.key)) {
        for (_i = 0, _len = relateds.length; _i < _len; _i++) {
          related = relateds[_i];
          if (Utils.dataIsSameModel(current_related_model, related)) {
            model.set(this.key, null);
            break;
          }
        }
      }
      related_ids = (function() {
        var _j, _len1, _results;
        _results = [];
        for (_j = 0, _len1 = relateds.length; _j < _len1; _j++) {
          related = relateds[_j];
          _results.push(Utils.dataId(related));
        }
        return _results;
      })();
      if (this.type === 'belongsTo') {
        return this.model_type.cursor({
          id: model.id,
          $one: true
        }).toJSON(function(err, model_json) {
          if (err) {
            return callback(err);
          }
          if (!model_json) {
            return callback();
          }
          if (!_.contains(related_ids, model_json[_this.foreign_key])) {
            return callback();
          }
          model_json[_this.foreign_key] = null;
          return Utils.modelJSONSave(model_json, _this.model_type, callback);
        });
      } else {
        return this.cursor(model, this.key).toJSON(function(err, related_json) {
          if (err) {
            return callback(err);
          }
          if (!related_json) {
            return callback();
          }
          if (!_.contains(related_ids, related_json.id)) {
            return callback();
          }
          related_json[_this.reverse_relation.foreign_key] = null;
          return Utils.modelJSONSave(related_json, _this.reverse_model_type, callback);
        });
      }
    };

    One.prototype.appendJSON = function(json, model) {
      var json_key, related_model;
      if (this.isVirtual()) {
        return;
      }
      json_key = this.embed ? this.key : this.foreign_key;
      if (!(related_model = model.attributes[this.key])) {
        if (this.embed || this.type === 'belongsTo') {
          json[json_key] = null;
        }
        return;
      }
      if (this.embed) {
        return json[json_key] = related_model.toJSON();
      }
      if (this.type === 'belongsTo') {
        return json[json_key] = related_model.id;
      }
    };

    One.prototype.cursor = function(model, key, query) {
      var _ref;
      query = _.extend({
        $one: true
      }, query || {});
      if (Utils.isModel(model)) {
        if (this.type === 'belongsTo') {
          if (!(query.id = (_ref = model.attributes[this.key]) != null ? _ref.id : void 0)) {
            query.$zero = true;
            delete query.id;
          }
        } else {
          if (!model.id) {
            throw new Error('Cannot create cursor for non-loaded model');
          }
          query[this.reverse_relation.foreign_key] = model.id;
        }
      } else {
        if (this.type === 'belongsTo') {
          if (!(query.id = model[this.foreign_key])) {
            query.$zero = true;
            delete query.id;
          }
        } else {
          if (!model.id) {
            throw new Error('Cannot create cursor for non-loaded model');
          }
          query[this.reverse_relation.foreign_key] = model.id;
        }
      }
      if (key === this.virtual_id_accessor) {
        query.$values = ['id'];
      }
      return this.reverse_model_type.cursor(query);
    };

    One.prototype._bindBacklinks = function(model) {
      var events, related_model, setBacklink,
        _this = this;
      if (!this.reverse_relation) {
        return;
      }
      events = Utils.set(model, 'events', {});
      setBacklink = function(related_model) {
        if (_this.reverse_relation.add) {
          return _this.reverse_relation.add(related_model, model);
        } else {
          return related_model.set(_this.reverse_relation.key, model);
        }
      };
      events.change = function(model) {
        var current_model, previous_related_model, related_model;
        related_model = model.get(_this.key);
        previous_related_model = model.previous(_this.key);
        if (Utils.dataId(related_model) === Utils.dataId(previous_related_model)) {
          return;
        }
        if (previous_related_model && (_this.reverse_relation && _this.reverse_relation.type !== 'belongsTo')) {
          if (_this.reverse_relation.remove) {
            if (!_this.isVirtual() || !related_model) {
              _this.reverse_relation.remove(previous_related_model, model);
            }
          } else {
            current_model = previous_related_model.get(_this.reverse_relation.key);
            if (Utils.dataId(current_model) === model.id) {
              previous_related_model.set(_this.reverse_relation.key, null);
            }
          }
        }
        if (related_model) {
          return setBacklink(related_model);
        }
      };
      model.on("change:" + this.key, events.change);
      if (related_model = model.get(this.key)) {
        setBacklink(related_model);
      }
      return model;
    };

    One.prototype._unbindBacklinks = function(model) {
      var events;
      if (!(events = Utils.get(model, 'events'))) {
        return;
      }
      Utils.unset(model, 'events');
      model.attributes[this.key] = null;
      model.off("change:" + this.key, events.change);
      events.change = null;
    };

    One.prototype._hasChanged = function(model) {
      var related_model;
      return !!Utils.orSet(model, 'rel_dirty', {})[this.key] || model.hasChanged(this.key);
      if (!this.reverse_relation) {
        return false;
      }
      if (!(related_model = model.attributes[this.key])) {
        return false;
      }
      return related_model.hasChanged(this.reverse_relation.foreign_key);
    };

    return One;

  })(require('./relation'));

}).call(this);
