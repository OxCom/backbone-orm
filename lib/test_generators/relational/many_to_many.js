// Generated by CoffeeScript 1.6.2
(function() {
  var Backbone, Fabricator, Queue, Utils, adapters, assert, runTests, util, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  util = require('util');

  assert = require('assert');

  _ = require('underscore');

  Backbone = require('backbone');

  Queue = require('queue-async');

  Fabricator = require('../../../fabricator');

  Utils = require('../../../utils');

  adapters = Utils.adapters;

  runTests = function(options, cache, embed) {
    var BASE_COUNT, BASE_SCHEMA, DATABASE_URL, Owner, Reverse, SYNC, _ref, _ref1;

    DATABASE_URL = options.database_url || '';
    BASE_SCHEMA = options.schema || {};
    SYNC = options.sync;
    BASE_COUNT = 1;
    Reverse = (function(_super) {
      __extends(Reverse, _super);

      function Reverse() {
        _ref = Reverse.__super__.constructor.apply(this, arguments);
        return _ref;
      }

      Reverse.prototype.url = "" + DATABASE_URL + "/reverses";

      Reverse.schema = {
        owners: function() {
          return ['hasMany', Owner];
        }
      };

      Reverse.prototype.sync = SYNC(Reverse, cache);

      return Reverse;

    })(Backbone.Model);
    Owner = (function(_super) {
      __extends(Owner, _super);

      function Owner() {
        _ref1 = Owner.__super__.constructor.apply(this, arguments);
        return _ref1;
      }

      Owner.prototype.url = "" + DATABASE_URL + "/owners";

      Owner.schema = {
        reverses: function() {
          return ['hasMany', Reverse];
        }
      };

      Owner.prototype.sync = SYNC(Owner, cache);

      return Owner;

    })(Backbone.Model);
    return describe("Many to Many (cache: " + cache + " embed: " + embed + ")", function() {
      beforeEach(function(done) {
        var MODELS, queue;

        MODELS = {};
        queue = new Queue(1);
        queue.defer(function(callback) {
          var destroy_queue;

          destroy_queue = new Queue();
          destroy_queue.defer(function(callback) {
            return Reverse.destroy(callback);
          });
          destroy_queue.defer(function(callback) {
            return Owner.destroy(callback);
          });
          return destroy_queue.await(callback);
        });
        queue.defer(function(callback) {
          var create_queue;

          create_queue = new Queue();
          create_queue.defer(function(callback) {
            return Fabricator.create(Reverse, 2 * BASE_COUNT, {
              name: Fabricator.uniqueId('reverses_'),
              created_at: Fabricator.date
            }, function(err, models) {
              MODELS.reverse = models;
              return callback(err);
            });
          });
          create_queue.defer(function(callback) {
            return Fabricator.create(Owner, BASE_COUNT, {
              name: Fabricator.uniqueId('owners_'),
              created_at: Fabricator.date
            }, function(err, models) {
              MODELS.owner = models;
              return callback(err);
            });
          });
          return create_queue.await(callback);
        });
        queue.defer(function(callback) {
          var owner, save_queue, _fn, _i, _len, _ref2;

          save_queue = new Queue();
          _ref2 = MODELS.owner;
          _fn = function(owner) {
            var reverse1, reverse2;

            owner.set({
              reverses: [reverse1 = MODELS.reverse.pop(), reverse2 = MODELS.reverse.pop()]
            });
            save_queue.defer(function(callback) {
              return owner.save({}, adapters.bbCallback(callback));
            });
            save_queue.defer(function(callback) {
              return reverse1.save({}, adapters.bbCallback(callback));
            });
            return save_queue.defer(function(callback) {
              return reverse2.save({}, adapters.bbCallback(callback));
            });
          };
          for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
            owner = _ref2[_i];
            _fn(owner);
          }
          return save_queue.await(callback);
        });
        return queue.await(done);
      });
      return it('Handles a get query for a hasMany and hasMany two sided relation', function(done) {
        return Owner.find({
          $one: true
        }, function(err, test_model) {
          assert.ok(!err, "No errors: " + err);
          assert.ok(test_model, 'found model');
          return test_model.get('reverses', function(err, reverses) {
            var reverse;

            assert.ok(!err, "No errors: " + err);
            assert.ok(reverses.length, 'found related reverses');
            if (test_model.relationIsEmbedded('reverses')) {
              assert.deepEqual(test_model.toJSON().reverses[0], reverses[0].toJSON(), "Serialized embedded. Expected: " + (test_model.toJSON().reverses) + ". Actual: " + (reverses[0].toJSON()));
            } else {
              assert.deepEqual(test_model.get('reverse_ids')[0], reverses[0].get('id'), "Serialized id only. Expected: " + (test_model.get('reverse_ids')[0]) + ". Actual: " + (reverses[0].get('id')));
            }
            reverse = reverses[0];
            return reverse.get('owners', function(err, owners) {
              var owner, owner_index;

              assert.ok(!err, "No errors: " + err);
              assert.ok(owners.length, 'found related models');
              owner = _.find(owners, function(test) {
                return test_model.get('id') === test.get('id');
              });
              owner_index = _.indexOf(owners, owner);
              if (reverse.relationIsEmbedded('owners')) {
                assert.deepEqual(reverse.toJSON().owner_ids[owner_index], owner.get('id'), "Serialized embedded. Expected: " + (reverse.toJSON().owner_ids[owner_index]) + ". Actual: " + (owner.get('id')));
              } else {
                assert.deepEqual(reverse.get('owner_ids')[owner_index], owner.get('id'), "Serialized id only. Expected: " + (reverse.get('owner_ids')[owner_index]) + ". Actual: " + (owner.get('id')));
              }
              assert.ok(!!owner, 'found owner');
              if (Owner.cache()) {
                assert.deepEqual(JSON.stringify(test_model.toJSON()), JSON.stringify(owner.toJSON()), "\nExpected: " + (util.inspect(test_model.toJSON())) + "\nActual: " + (util.inspect(test_model.toJSON())));
              } else {
                assert.equal(test_model.get('id'), owner.get('id'), "\nExpected: " + (test_model.get('id')) + "\nActual: " + (owner.get('id')));
              }
              return done();
            });
          });
        });
      });
    });
  };

  module.exports = function(options) {
    runTests(options, false, false);
    runTests(options, true, false);
    if (options.embed) {
      runTests(options, false, true);
    }
    if (options.embed) {
      return runTests(options, true, true);
    }
  };

}).call(this);
