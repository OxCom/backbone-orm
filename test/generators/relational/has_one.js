// Generated by CoffeeScript 1.6.2
(function() {
  var Backbone, Fabricator, JSONUtils, Queue, Utils, adapters, assert, runTests, util, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  util = require('util');

  assert = require('assert');

  _ = require('underscore');

  Backbone = require('backbone');

  Queue = require('queue-async');

  Fabricator = require('../../../fabricator');

  Utils = require('../../../lib/utils');

  JSONUtils = require('../../../lib/json_utils');

  adapters = Utils.adapters;

  runTests = function(options, cache, embed) {
    var BASE_COUNT, BASE_SCHEMA, DATABASE_URL, Flat, Owner, Reverse, SYNC, _ref, _ref1, _ref2;

    DATABASE_URL = options.database_url || '';
    BASE_SCHEMA = options.schema || {};
    SYNC = options.sync;
    BASE_COUNT = 1;
    Flat = (function(_super) {
      __extends(Flat, _super);

      function Flat() {
        _ref = Flat.__super__.constructor.apply(this, arguments);
        return _ref;
      }

      Flat.prototype.urlRoot = "" + DATABASE_URL + "/flats";

      Flat.schema = BASE_SCHEMA;

      Flat.prototype.sync = SYNC(Flat, cache);

      return Flat;

    })(Backbone.Model);
    Reverse = (function(_super) {
      __extends(Reverse, _super);

      function Reverse() {
        _ref1 = Reverse.__super__.constructor.apply(this, arguments);
        return _ref1;
      }

      Reverse.prototype.urlRoot = "" + DATABASE_URL + "/reverses";

      Reverse.schema = _.defaults({
        owner: function() {
          return ['belongsTo', Owner];
        }
      }, BASE_SCHEMA);

      Reverse.prototype.sync = SYNC(Reverse, cache);

      return Reverse;

    })(Backbone.Model);
    Owner = (function(_super) {
      __extends(Owner, _super);

      function Owner() {
        _ref2 = Owner.__super__.constructor.apply(this, arguments);
        return _ref2;
      }

      Owner.prototype.urlRoot = "" + DATABASE_URL + "/owners";

      Owner.schema = _.defaults({
        flat: function() {
          return [
            'belongsTo', Flat, {
              embed: embed
            }
          ];
        },
        reverse: function() {
          return [
            'hasOne', Reverse, {
              embed: embed
            }
          ];
        }
      }, BASE_SCHEMA);

      Owner.prototype.sync = SYNC(Owner, cache);

      return Owner;

    })(Backbone.Model);
    return describe("hasOne (cache: " + cache + " embed: " + embed + ")", function() {
      beforeEach(function(done) {
        var MODELS, queue;

        MODELS = {};
        queue = new Queue(1);
        queue.defer(function(callback) {
          var destroy_queue;

          destroy_queue = new Queue();
          destroy_queue.defer(function(callback) {
            return Flat.destroy(callback);
          });
          destroy_queue.defer(function(callback) {
            return Reverse.destroy(callback);
          });
          destroy_queue.defer(function(callback) {
            return Owner.destroy(callback);
          });
          return destroy_queue.await(callback);
        });
        queue.defer(function(callback) {
          var create_queue;

          create_queue = new Queue();
          create_queue.defer(function(callback) {
            return Fabricator.create(Flat, BASE_COUNT, {
              name: Fabricator.uniqueId('flat_'),
              created_at: Fabricator.date
            }, function(err, models) {
              MODELS.flat = models;
              return callback(err);
            });
          });
          create_queue.defer(function(callback) {
            return Fabricator.create(Reverse, BASE_COUNT, {
              name: Fabricator.uniqueId('reverse_'),
              created_at: Fabricator.date
            }, function(err, models) {
              MODELS.reverse = models;
              return callback(err);
            });
          });
          create_queue.defer(function(callback) {
            return Fabricator.create(Owner, BASE_COUNT, {
              name: Fabricator.uniqueId('owner_'),
              created_at: Fabricator.date
            }, function(err, models) {
              MODELS.owner = models;
              return callback(err);
            });
          });
          return create_queue.await(callback);
        });
        queue.defer(function(callback) {
          var owner, reverses, save_queue, _fn, _i, _len, _ref3;

          save_queue = new Queue();
          reverses = MODELS.reverse.slice();
          _ref3 = MODELS.owner;
          _fn = function(owner) {
            owner.set({
              flat: MODELS.flat.pop(),
              reverse: reverses.pop()
            });
            return save_queue.defer(function(callback) {
              return owner.save({}, adapters.bbCallback(callback));
            });
          };
          for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
            owner = _ref3[_i];
            _fn(owner);
          }
          return save_queue.await(callback);
        });
        return queue.await(done);
      });
      it('Fetches a relation from the store if not present', function(done) {
        return Owner.find({
          $one: true
        }, function(err, test_model) {
          var fetched_owner;

          assert.ok(!err, "No errors: " + err);
          assert.ok(test_model, 'found model');
          fetched_owner = new Owner({
            id: test_model.get('id')
          });
          return fetched_owner.fetch(adapters.bbCallback(function(err) {
            var reverse;

            assert.ok(!err, "No errors: " + err);
            delete fetched_owner.attributes.reverse;
            return reverse = fetched_owner.get('reverse', function(err, reverse) {
              assert.ok(!err, "No errors: " + err);
              assert.ok(reverse, 'loaded the model lazily');
              assert.equal(reverse.get('owner_id'), test_model.get('id'));
              return done();
            });
          }));
        });
      });
      it('Has an id loaded for a belongsTo and not for a hasOne relation', function(done) {
        return Owner.find({
          $one: true
        }, function(err, test_model) {
          assert.ok(!err, "No errors: " + err);
          assert.ok(test_model, 'found model');
          assert.ok(test_model.get('flat_id'), 'belongsTo id is loaded');
          return done();
        });
      });
      it('Handles a get query for a belongsTo relation', function(done) {
        return Owner.find({
          $one: true
        }, function(err, test_model) {
          assert.ok(!err, "No errors: " + err);
          assert.ok(test_model, 'found model');
          return test_model.get('flat', function(err, flat) {
            assert.ok(!err, "No errors: " + err);
            assert.ok(flat, 'found related model');
            if (test_model.relationIsEmbedded('flat')) {
              assert.deepEqual(test_model.toJSON().flat, flat.toJSON(), "Serialized embed. Expected: " + (util.inspect(test_model.toJSON().flat)) + ". Actual: " + (util.inspect(flat.toJSON())));
            } else {
              assert.deepEqual(test_model.toJSON().flat_id, flat.get('id'), "Serialized id only. Expected: " + (test_model.toJSON().flat_id) + ". Actual: " + (flat.get('id')));
            }
            assert.equal(test_model.get('flat_id'), flat.get('id'), "\nExpected: " + (test_model.get('flat_id')) + "\nActual: " + (flat.get('id')));
            return done();
          });
        });
      });
      it('Can retrieve an id for a hasOne relation via async virtual method', function(done) {
        return Owner.find({
          $one: true
        }, function(err, test_model) {
          assert.ok(!err, "No errors: " + err);
          assert.ok(test_model, 'found model');
          return test_model.get('reverse_id', function(err, id) {
            assert.ok(!err, "No errors: " + err);
            assert.ok(id, 'found id');
            return done();
          });
        });
      });
      it('Handles a get query for a hasOne relation', function(done) {
        return Owner.find({
          $one: true
        }, function(err, test_model) {
          assert.ok(!err, "No errors: " + err);
          assert.ok(test_model, 'found model');
          return test_model.get('reverse', function(err, reverse) {
            assert.ok(!err, "No errors: " + err);
            assert.ok(reverse, 'found related model');
            assert.equal(test_model.get('id'), reverse.get('owner_id'), "\nExpected: " + (test_model.get('id')) + "\nActual: " + (reverse.get('owner_id')));
            assert.equal(test_model.get('id'), reverse.toJSON().owner_id, "\nReverse toJSON has an owner_id. Expected: " + (test_model.get('id')) + "\nActual: " + (reverse.toJSON().owner_id));
            if (test_model.relationIsEmbedded('reverse')) {
              assert.deepEqual(test_model.toJSON().reverse, reverse.toJSON(), "Serialized embed. Expected: " + (util.inspect(test_model.toJSON().reverse)) + ". Actual: " + (util.inspect(reverse.toJSON())));
            }
            assert.ok(!test_model.toJSON().reverse_id, 'No reverese_id in owner json');
            return done();
          });
        });
      });
      it('Handles a get query for a hasOne and belongsTo two sided relation', function(done) {
        return Owner.find({
          $one: true
        }, function(err, test_model) {
          assert.ok(!err, "No errors: " + err);
          assert.ok(test_model, 'found model');
          return test_model.get('reverse', function(err, reverse) {
            assert.ok(!err, "No errors: " + err);
            assert.ok(reverse, 'found related model');
            assert.equal(test_model.get('id'), reverse.get('owner_id'), "\nExpected: " + (test_model.get('id')) + "\nActual: " + (reverse.get('owner_id')));
            assert.equal(test_model.get('id'), reverse.toJSON().owner_id, "\nReverse toJSON has an owner_id. Expected: " + (test_model.get('id')) + "\nActual: " + (reverse.toJSON().owner_id));
            if (test_model.relationIsEmbedded('reverse')) {
              assert.deepEqual(test_model.toJSON().reverse, reverse.toJSON(), "Serialized embed. Expected: " + (util.inspect(test_model.toJSON().reverse)) + ". Actual: " + (util.inspect(reverse.toJSON())));
            }
            assert.ok(!test_model.toJSON().reverse_id, 'No reverese_id in owner json');
            return reverse.get('owner', function(err, owner) {
              assert.ok(!err, "No errors: " + err);
              assert.ok(owner, 'found original model');
              assert.deepEqual(reverse.toJSON().owner_id, owner.get('id'), "Serialized id only. Expected: " + (reverse.toJSON().owner_id) + ". Actual: " + (owner.get('id')));
              if (Owner.cache()) {
                assert.deepEqual(JSON.stringify(test_model.toJSON()), JSON.stringify(owner.toJSON()), "\nExpected: " + (util.inspect(test_model.toJSON())) + "\nActual: " + (util.inspect(owner.toJSON())));
              } else {
                assert.equal(test_model.get('id'), owner.get('id'), "\nExpected: " + (test_model.get('id')) + "\nActual: " + (owner.get('id')));
              }
              return done();
            });
          });
        });
      });
      return it('Appends json for a related model', function(done) {
        return Owner.find({
          $one: true
        }, function(err, test_model) {
          var json;

          assert.ok(!err, "No errors: " + err);
          assert.ok(test_model, 'found model');
          json = {};
          return JSONUtils.appendRelatedJSON(json, test_model, 'reverse', ['id', 'created_at'], function(err) {
            console.log(json);
            assert.ok(!err, "No errors: " + err);
            assert.ok(json.reverse, "json has a reverse");
            assert.ok(json.reverse.id, "reverse has an id");
            assert.ok(json.reverse.created_at, "reverse has a created_at");
            assert.ok(!json.reverse.updated_at, "reverse doesn't have updated_at");
            return JSONUtils.appendRelatedJSON(json, test_model, 'flat', ['id', 'created_at'], function(err) {
              assert.ok(!err, "No errors: " + err);
              assert.ok(json.flat, "json has a flat");
              assert.ok(json.flat.id, "flat has an id");
              assert.ok(!json.flat.updated_at, "flat doesn't have updated_at");
              return done();
            });
          });
        });
      });
    });
  };

  module.exports = function(options) {
    runTests(options, false, false);
    runTests(options, true, false);
    if (options.embed) {
      runTests(options, false, true);
    }
    if (options.embed) {
      return runTests(options, true, true);
    }
  };

}).call(this);

/*
//@ sourceMappingURL=has_one.map
*/
